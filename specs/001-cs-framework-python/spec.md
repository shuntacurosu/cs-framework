# Feature Specification: C-S Framework for Python

**Feature Branch**: `001-cs-framework-python`
**Created**: 2025-12-06
**Status**: Draft
**Input**: User description: "C-S憲章を実現するpythonフレームワークを作りたい"

## User Scenarios & Testing

### User Story 1 - Define and Execute Independent Concepts (Priority: P1)

As a developer, I want to define Concepts and Synchronizations using Python classes/functions so that I can build an application compliant with the C-S Constitution.

**Why this priority**: This is the core functionality of the framework. Without this, no C-S application can be built.

**Independent Test**: Create two simple Concepts (e.g., `Source` and `Target`) and one Synchronization. Trigger an action on `Source` and verify `Target` is updated automatically.

**Acceptance Scenarios**:

1. **Given** a defined `ConceptA` and `ConceptB`, **When** I define a Synchronization linking `ConceptA`'s event to `ConceptB`'s action, **Then** the framework registers this rule without modifying `ConceptA` or `ConceptB`.
2. **Given** the registered Synchronization, **When** I execute an action on `ConceptA`, **Then** `ConceptB`'s action is executed subsequently.
3. **Given** the execution, **Then** the internal state of both Concepts is updated correctly.

---

### User Story 2 - Generate Traceable Execution Logs (Priority: P1)

As an LLM (or developer), I want to see a detailed, structured log of the system's execution so that I can debug issues and understand the causal chain of events.

**Why this priority**: Essential for "autonomous debugging" by LLMs and meeting the "Transparency" principle of the C-S Constitution.

**Independent Test**: Run the test case from User Story 1 and inspect the output log.

**Acceptance Scenarios**:

1. **Given** a running C-S application, **When** an action is performed, **Then** the framework outputs a log entry.
2. **Given** a chain of events (Action A -> Sync -> Action B), **Then** the log MUST capture the causal relationship (Action B happened *because* of Sync, which triggered *because* of Action A).
3. **Given** the log output, **Then** it MUST be in RDF (Turtle) format, utilizing `rdflib` as requested, to ensure machine readability and structure.
4. **Given** a Synchronization execution, **Then** the log MUST treat the Synchronization itself as an entity (Concept) with its own identity/trace.

---

### User Story 3 - Visualize Execution State (Priority: P2)

As a human developer, I want to view the system execution as a graphical flowchart so that I can intuitively understand the complex interactions between Concepts.

**Why this priority**: Reduces cognitive load for human reviewers and fulfills the "human responsibility" aspect.

**Independent Test**: Open the GUI application and load the log file generated in User Story 2.

**Acceptance Scenarios**:

1. **Given** a generated log file (Turtle format), **When** I load it into the GUI tool, **Then** I see a graph visualization.
2. **Given** the graph, **Then** nodes represent Concepts/Actions and edges represent Synchronizations/Data flow.
3. **Given** the GUI, **When** the application is running, **Then** I can optionally see the graph update in real-time (or by refreshing the log).

### Edge Cases

- **Circular Dependencies**: What happens if Sync A triggers Sync B which triggers Sync A? The framework should detect or limit recursion depth.
- **Error Handling**: What happens if a Synchronization fails? The log should record the failure, and the system should continue or halt based on configuration (C-S implies "error handling as normal action completion").
- **Concurrency**: What happens if multiple actions occur simultaneously? The log should serialize them or record timestamps accurately.

## Requirements

### Functional Requirements

#### Core Framework
- **FR-001**: The system MUST provide a base structure (classes/decorators) to define **Concepts** that encapsulate state and actions.
- **FR-002**: Concepts MUST be independent; they MUST NOT import or reference other Concepts directly in their definition.
- **FR-003**: The system MUST provide a mechanism to define **Synchronizations** using a "When-Where-Then" pattern: "When" (Event), "Where" (State Condition), and "Then" (One or more Actions).
- **FR-004**: The system MUST treat Synchronizations as first-class entities (Concepts) that can be identified and traced.
- **FR-005**: The runtime engine MUST execute Synchronizations based on events generated by Concepts.
- **FR-014**: Concepts MUST provide a read-only view of their state via a standard API (e.g., `get_state_snapshot`) for use in Synchronization conditions.
- **FR-015**: The system MUST handle Action failures by emitting failure events, allowing Synchronizations to react to errors (Error as Data).

#### Logging & Traceability
- **FR-006**: The system MUST log every Action execution, State change, and Synchronization trigger.
- **FR-007**: The log output MUST be in **RDF (Turtle)** format.
- **FR-008**: The log MUST explicitly record the "cause" of every change (e.g., `ActionB wasTriggeredBy SyncX`, `SyncX wasTriggeredBy ActionA`).
- **FR-009**: The system MUST support outputting logs to both a file and the console (stdout).

#### Visualization (GUI)
- **FR-010**: The system MUST include a browser-based GUI application developed in Python (e.g., Streamlit, Dash, or similar).
- **FR-011**: The GUI MUST be able to parse the RDF/Turtle log files using `rdflib` and `SPARQL` queries to extract the execution graph.
- **FR-012**: The GUI MUST render a directed graph where nodes are Concepts/Actions and edges are Synchronizations/Causal links.
- **FR-013**: The GUI MUST support auto-refresh or "tailing" of the log file to simulate real-time visualization.

### Key Entities

- **Concept**: An independent module with State and Actions.
- **Action**: A discrete operation performed on a Concept.
- **Event**: A signal that an Action has completed or State has changed.
- **Synchronization**: A declarative rule linking Events to Actions.
- **Trace/Log**: An RDF graph recording the history of all Actions and Synchronizations.

### Assumptions
- The user has a Python environment with `rdflib` installed (or can install it).
- The "C-S Constitution" principles (Concept-Based Modularity, Synchronization-Based Composition, etc.) are the source of truth for architectural decisions.
- "Real-time" visualization can be achieved by polling the log file or a shared in-memory graph.
